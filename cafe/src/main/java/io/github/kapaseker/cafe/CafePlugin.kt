package io.github.kapaseker.cafe

import com.android.build.gradle.BaseExtension
import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.LambdaTypeName
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import groovy.util.Node
import groovy.xml.XmlParser
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.provider.SetProperty
import java.io.File
import java.util.Locale

private const val TASK_CAFE = "cafe"
private const val EXTENSION = "cafe"
private const val MAIN_COFFEE = "main"

private const val COFFEE = "Coffee"
private const val CUP = "Cup"
private const val CAFE = "Cafe"
private const val PROVIDER = "Provider"
private const val CAFE_THEME = "CafeTheme"
private const val CAFE_PROVIDER = CAFE + PROVIDER

private const val FILE_COMMENT = "this file is auto-generated, please do not edit this file。\n该文件是自动生成的文件，请不要编辑。\n"

interface CafePluginExtension {
    val cup: SetProperty<String>
}

enum class ResourceReadType {
    FILE, XML
}

private val composeAnnotation = ClassName("androidx.compose.runtime", "Composable")

class CafePlugin : Plugin<Project> {

    data class CafeResource(
        val name: String,
        val type: ResourceReadType,
        val annotation: ClassName,
        val resMap: MutableMap<String, MutableList<String>> = mutableMapOf(),
        val resSet: MutableSet<String> = mutableSetOf<String>()
    )

    private val cafeResources = listOf<CafeResource>(
        CafeResource("color", ResourceReadType.XML, ClassName("androidx.annotation", "ColorRes")),
        CafeResource("mipmap", ResourceReadType.FILE, ClassName("androidx.annotation", "DrawableRes")),
        CafeResource("drawable", ResourceReadType.FILE, ClassName("androidx.annotation", "DrawableRes")),
    )

    override fun apply(target: Project) {

        println("generate cafe")

        val cafeExtension = target.extensions.create(EXTENSION, CafePluginExtension::class.java)
        cafeExtension.cup.convention(emptySet())

        target.tasks.register(TASK_CAFE) task@{

            target.androidProject()?.let { android ->
                println("make app coffee for ${android.namespace}")
                val cafeDir = android.sourceSets.getByName("main").java.srcDirs.first()
                generateCafeFile(namespace = android.namespace.orEmpty(), variant = "", target = android, buildDir = target.layout.buildDirectory.asFile.get(), cups = cafeExtension.cup.get(), outDir = cafeDir)
                return@task
            }

            target.libraryProject()?.let { android ->
                println("make library coffee for ${android.namespace}")
                val cafeDir = android.sourceSets.getByName("main").java.srcDirs.first()
                generateCafeFile(namespace = android.namespace.orEmpty(), variant = "", target = android, buildDir = target.layout.buildDirectory.asFile.get(), cups = cafeExtension.cup.get(), outDir = cafeDir)
                return@task
            }
        }
        target.tasks.getByName("preBuild").finalizedBy(TASK_CAFE)
    }

    private fun makeResCoffee(res: String, cups: Set<String>): String {
        if (cups.isEmpty()) {
            return MAIN_COFFEE
        }
        for (coffee in cups) {
            if (res.lastIndexOf("_$coffee") > -1) {
                return coffee
            }
        }
        return MAIN_COFFEE
    }

    private fun makeResKey(res: String, cups: Set<String>): String {
        if (cups.isEmpty()) {
            return res
        }
        for (coffee in cups) {
            val suffixCoffee = res.lastIndexOf("_$coffee")
            if (suffixCoffee > -1) {
                return res.substring(0, suffixCoffee)
            }
        }
        return res
    }

    private fun generateCafeFile(
        namespace: String,
        variant: String,
        target: BaseExtension,
        buildDir: File,
        cups: Set<String>,
        outDir: File
    ) {

        println("make $cups coffee")

        val mainSet = target.sourceSets.getByName("main")

        val coffeeList = mutableListOf<TypeSpec.Builder>()

        val cupMap = mutableMapOf<String, TypeSpec.Builder>()
        cupMap[MAIN_COFFEE] = TypeSpec.objectBuilder(MAIN_COFFEE.uppercase()).addSuperinterface(cupClass(namespace))

//        val colorMap = mutableMapOf<String, MutableList<String>>()
//        val colorSet = mutableSetOf<String>()
//
//        val mipmapMap = mutableMapOf<String, MutableList<String>>()
//        val mipmapSet = mutableSetOf<String>()
//
//        val drawableMap = mutableMapOf<String, MutableList<String>>()
//        val drawableSet = mutableSetOf<String>()

        for (obj in cups) {
            cupMap[obj] = TypeSpec.objectBuilder(obj.uppercase()).addSuperinterface(cupClass(namespace))
            for (resource in cafeResources) {
                resource.resMap[obj] = mutableListOf()
            }
        }

        for (resFile in mainSet.res.srcDirs) {
            val files = resFile.listFiles().orEmpty()
            for (folder in files) {
                when {
                    folder.name.startsWith("values") -> {
                        for (resource in cafeResources.filter { it.type == ResourceReadType.XML }) {
                            processValuesFolder(resource.name, folder, resource.resSet, resource.resMap, cups)
                        }
                    }

                    else -> {
                        for (resource in cafeResources.filter { it.type == ResourceReadType.FILE }) {
                            if (folder.name.startsWith(resource.name)) {
                                processResourceFolder(folder, resource.resSet, resource.resMap, cups)
                            }
                        }
                    }
                }
            }
        }

        for (resource in cafeResources) {
            makeResourceCoffee(cupName = resource.name, annotation = resource.annotation, namespace = namespace, cupMap = resource.resMap, cupList = coffeeList)
            makeResourceCup(
                resName = resource.name, namespace = namespace, resMap = resource.resMap, typeList = cupMap, coffee = cups
            )
        }

        val coffees = cafeResources.map { it.name }.toTypedArray()

        val coffeeFile = FileSpec.builder(coffeeClass(namespace))
        coffeeFile.addFileComment(FILE_COMMENT)

        for (cup in coffeeList) {
            coffeeFile.addType(cup.build())
        }

        coffeeFile.build().writeTo(outDir)

        val cupFile = FileSpec.builder(cupClass(namespace))
        cupFile.addFileComment(FILE_COMMENT)

        cupFile.addType(makeCupInterface(namespace, coffees))

        for (obj in cupMap.values) {
            cupFile.addType(obj.build())
        }

        cupFile.build().writeTo(outDir)


        val cafeFile = FileSpec.builder(cafeClass(namespace))
        cafeFile.addFileComment(FILE_COMMENT)

        val cafeProviderObj = TypeSpec.objectBuilder(CAFE_PROVIDER)
//            .addModifiers(KModifier.PRIVATE)

        for (type in coffees) {
            cafeProviderObj.addProperty(
                PropertySpec.builder(
                    name = type + PROVIDER, type = ClassName("androidx.compose.runtime", "ProvidableCompositionLocal").parameterizedBy(cafeResourceClass(namespace, type))
                ).initializer(
                    CodeBlock.builder().addStatement("staticCompositionLocalOf<%L> { error(\"null\") }", CAFE + type.capitalized()).build()
                ).build()
            )
        }

        cafeProviderObj.addProperty(
            PropertySpec.builder(
                "cupFlow", ClassName("kotlinx.coroutines.flow", "MutableStateFlow").parameterizedBy(cupClass(namespace))
            ).initializer(
                    CodeBlock.builder().addStatement("MutableStateFlow(MAIN)").build()
                ).build()
        )


        val cafeObj = TypeSpec.objectBuilder(CAFE)

        for (type in coffees) {
            cafeObj.addProperty(
                PropertySpec.builder(type, cafeResourceClass(namespace, type)).getter(
                        FunSpec.getterBuilder().addAnnotation(composeAnnotation).addStatement("return $CAFE_PROVIDER.$type$PROVIDER.current").build()
                    ).build()
            )
        }


        cafeObj.addFunction(
            FunSpec.builder("set$CUP").addParameter(CUP.lowercase(), cupClass(namespace)).addStatement("$CAFE_PROVIDER.${CUP.lowercase()}Flow.tryEmit(${CUP.lowercase()})").build()
        )

        cafeObj.addFunction(
            FunSpec.builder("getCup").returns(cupClass(namespace)).addStatement("return $CAFE_PROVIDER.cupFlow.value").build()
        )

        val cafeFunc = FunSpec.builder(CAFE_THEME)

        cafeFunc.addAnnotation(composeAnnotation)
        cafeFunc.addParameter(
            ParameterSpec.builder(
                "content", LambdaTypeName.get(returnType = ClassName("kotlin", "Unit")).copy(
                    annotations = listOf(AnnotationSpec.builder(composeAnnotation).build())
                )
            ).build()
        )

        val compositionProvidesCode = StringBuilder()

        for (type in coffees) {
            compositionProvidesCode.append("$CAFE_PROVIDER.$type$PROVIDER provides cup.$type,\n")
        }

        cafeFunc.addCode(
            CodeBlock.builder().addStatement(
                """
                val cup by $CAFE_PROVIDER.cupFlow.collectAsState()

                CompositionLocalProvider(
                    %L
                ) {
                    content()
                }
            """.trimIndent(), compositionProvidesCode.toString()
            ).build()
        )

        cafeFile.addImport(
            "androidx.compose.runtime", *arrayOf(
                "Composable", "CompositionLocalProvider", "ProvidableCompositionLocal", "collectAsState", "getValue", "staticCompositionLocalOf"
            )
        )

        cafeFile.addType(cafeObj.build())
        cafeFile.addType(cafeProviderObj.build())
        cafeFile.addFunction(cafeFunc.build())

        cafeFile.build().writeTo(outDir)
    }

    private fun makeCupInterface(
        namespace: String,
        resNames: Array<String>
    ): TypeSpec {
        val coffeeInterface = TypeSpec.interfaceBuilder(CUP).addModifiers(KModifier.PUBLIC)
        for (res in resNames) {
            coffeeInterface.addProperty(res, cafeResourceClass(namespace, res))
        }
        return coffeeInterface.build()
    }

    private fun makeResourceCoffee(
        cupName: String,
        annotation: ClassName,
        namespace: String,
        cupMap: Map<String, MutableList<String>>,
        cupList: MutableList<TypeSpec.Builder>,
    ) {
        val cupType = TypeSpec.classBuilder(CAFE + cupName.capitalized()).addModifiers(KModifier.PUBLIC)
        for (res in cupMap[MAIN_COFFEE].orEmpty()) {
            cupType
                .addProperty(
                    PropertySpec
                        .builder(res, Int::class, KModifier.PUBLIC)
                        .mutable()
                        .addAnnotation(annotation)
                        .initializer("${namespace}.R.${cupName}.%L", res)
                        .build()
                )
        }
        cupList.add(cupType)
    }

    private fun makeResourceCup(
        resName: String,
        namespace: String,
        resMap: Map<String, MutableList<String>>,
        typeList: MutableMap<String, TypeSpec.Builder>,
        coffee: Set<String>
    ) {
        //除了主资源以外，其他资源补完
        val mainSet = resMap[MAIN_COFFEE]?.map { makeResKey(it, coffee) }?.toSet().orEmpty()
        for (res in resMap) {
            if (res.key == MAIN_COFFEE) {
                continue
            }
            val coffeeSet = res.value.map { makeResKey(it, coffee) }.toSet()
            for (main in mainSet) {
                if (!coffeeSet.contains(main)) {
                    res.value.add(main)
                }
            }
        }
        for (res in resMap) {
            typeList[res.key]?.let { type ->
                val properties = mutableListOf<Pair<String, String>>()
                for (resFile in res.value) {
                    val name = makeResKey(resFile, coffee)
                    val value = "${namespace}.R.${resName}." + resFile
                    properties.add(name to value)
                }

                println("$resName has properties : $properties")

                val property = PropertySpec.builder(
                    resName, cafeResourceClass(namespace, resName), KModifier.PUBLIC, KModifier.OVERRIDE
                ).initializer(
                        CodeBlock
                            .builder()
                            .addStatement(
                                "%L().apply{\n%L\n}",
                                CAFE + resName.capitalized(),
                                properties.joinToString("\n") { "${it.first} = ${it.second}" }
                            )
                            .build()
                    )
                type.addProperty(property.build())
            }
        }
    }

    private fun processResourceFolder(
        folder: File, resSet: MutableSet<String>, resMap: MutableMap<String, MutableList<String>>, cups: Set<String>
    ) {
        for (valueFile in folder.listFiles().orEmpty()) {
            val resFileName = valueFile.name.substring(0, valueFile.name.indexOf('.'))
            if (resSet.contains(resFileName)) {
                continue
            }
            resSet.add(resFileName)
            resMap.getOrPut(makeResCoffee(resFileName, cups)) { mutableListOf() }.add(resFileName)
        }
    }

    private fun processValuesFolder(
        resName: String,
        folder: File,
        resSet: MutableSet<String>,
        resMap: MutableMap<String, MutableList<String>>,
        cups: Set<String>
    ) {
        for (valueFile in folder.listFiles().orEmpty()) {
            val values = XmlParser().parse(valueFile)
            for (child in values.children()) {
                (child as? Node)?.let { node ->
                    val nodeName = node.name().toString()
                    if (resName == nodeName) {
                        val resValue = node.attribute("name").toString().replace('.', '_')
                        if (resSet.contains(resValue)) {
                            return@let
                        }
                        resSet.add(resValue)
                        resMap.getOrPut(makeResCoffee(resValue, cups)) { mutableListOf() }.add(resValue)
                    }
                }
            }
        }
    }


    private fun makePackageName(pkg: String) = "$pkg.$EXTENSION"

    private fun cupClass(pkg: String) = ClassName(makePackageName(pkg), CUP)
    private fun coffeeClass(pkg: String) = ClassName(makePackageName(pkg), COFFEE)
    private fun cafeClass(pkg:String) = ClassName(makePackageName(pkg), CAFE)

    private fun cafeResourceClass(pkg:String, res:String) = ClassName(makePackageName(pkg), CAFE + res.capitalized())

    private fun String.capitalized() = this.replaceFirstChar { if (it.isLowerCase()) it.titlecase(Locale.ROOT) else it.toString() }
}
