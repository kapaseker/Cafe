package cn.loopon.cafe

import com.android.build.gradle.BaseExtension
import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.LambdaTypeName
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import groovy.util.Node
import groovy.xml.XmlParser
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.provider.SetProperty
import org.gradle.configurationcache.extensions.capitalized
import java.io.File

private const val CAFE_PACKAGE = "cn.loopon.cafe"
private const val TASK_CAFE = "cafe"
private const val EXTENSION = "cafe"
private const val MAIN_COFFEE = "main"

private const val COFFEE = "Coffee"
private const val CUP = "Cup"
private const val CAFE = "Cafe"
private const val PROVIDER = "Provider"
private const val CAFE_THEME = "CafeTheme"
private const val CAFE_PROVIDER = CAFE + PROVIDER

private const val FILE_COMMENT = "this file is auto-generated, please do not edit this file。\n该文件是自动生成的文件，请不要编辑。\n"

interface CafePluginExtension {
    val cup: SetProperty<String>
}

enum class ResourceReadType {
    FILE, XML
}

private val composeAnnotation = ClassName("androidx.compose.runtime", "Composable")
private val cupClass = ClassName(CAFE_PACKAGE, CUP)
private val coffeeClass = ClassName(CAFE_PACKAGE, COFFEE)

class CafePlugin : Plugin<Project> {

    data class CafeResource(
        val name: String,
        val type: ResourceReadType,
        val annotation: ClassName,
        val resMap: MutableMap<String, MutableList<String>> = mutableMapOf(),
        val resSet: MutableSet<String> = mutableSetOf<String>()
    )

    private val cafeResources = listOf<CafeResource>(
        CafeResource("color", ResourceReadType.XML, ClassName("androidx.annotation", "ColorRes")),
        CafeResource("mipmap", ResourceReadType.FILE, ClassName("androidx.annotation", "DrawableRes")),
        CafeResource("drawable", ResourceReadType.FILE, ClassName("androidx.annotation", "DrawableRes")),
    )

    init {
        println("Cafe init")
    }

    override fun apply(target: Project) {

        println("apply cafe")

        val cafeExtension = target.extensions.create(EXTENSION,CafePluginExtension::class.java)
        cafeExtension.cup.convention(emptySet())

        target.tasks.register(TASK_CAFE) task@{

            target.androidProject()?.let { android ->
                println("make app coffee for ${android.namespace}")
                val cafeDir = android.sourceSets.getByName("main").java.srcDirs.first()
                generateCafeFile(namespace = android.namespace.orEmpty(), variant = "", target = android, buildDir = target.buildDir, cups = cafeExtension.cup.get(), outDir = cafeDir)
                return@task
            }

            target.libraryProject()?.let { android ->
                println("make library coffee for ${android.namespace}")
                val cafeDir = android.sourceSets.getByName("main").java.srcDirs.first()
                generateCafeFile(namespace = android.namespace.orEmpty(), variant = "", target = android, buildDir = target.buildDir, cups = cafeExtension.cup.get(), outDir = cafeDir)
                return@task
            }
        }
        target.tasks.getByName("preBuild").finalizedBy(TASK_CAFE)
    }

    private fun makeResCoffee(res: String, cups: Set<String>): String {
        if (cups.isEmpty()) {
            return MAIN_COFFEE
        }
        for (coffee in cups) {
            if (res.lastIndexOf("_$coffee") > -1) {
                return coffee
            }
        }
        return MAIN_COFFEE
    }

    private fun makeResKey(res: String, cups: Set<String>): String {
        if (cups.isEmpty()) {
            return res
        }
        for (coffee in cups) {
            val suffixCoffee = res.lastIndexOf("_$coffee")
            if (suffixCoffee > -1) {
                return res.substring(0, suffixCoffee)
            }
        }
        return res
    }

    private fun generateCafeFile(namespace: String, variant: String, target: BaseExtension, buildDir: File, cups: Set<String>, outDir: File) {

        println("make $cups coffee")

        val mainSet = target.sourceSets.getByName("main")

        val coffeeList = mutableListOf<TypeSpec.Builder>()

        val cupMap = mutableMapOf<String, TypeSpec.Builder>()
        cupMap[MAIN_COFFEE] = TypeSpec.objectBuilder(MAIN_COFFEE.uppercase()).addSuperinterface(cupClass)

//        val colorMap = mutableMapOf<String, MutableList<String>>()
//        val colorSet = mutableSetOf<String>()
//
//        val mipmapMap = mutableMapOf<String, MutableList<String>>()
//        val mipmapSet = mutableSetOf<String>()
//
//        val drawableMap = mutableMapOf<String, MutableList<String>>()
//        val drawableSet = mutableSetOf<String>()

        for (obj in cups) {
            cupMap[obj] = TypeSpec.objectBuilder(obj.uppercase()).addSuperinterface(cupClass)
            for (resource in cafeResources) {
                resource.resMap[obj] = mutableListOf()
            }
        }

        for (resFile in mainSet.res.srcDirs) {
            val files = resFile.listFiles().orEmpty()
            for (folder in files) {
                when {
                    folder.name.startsWith("values") -> {
                        for (resource in cafeResources.filter { it.type == ResourceReadType.XML }) {
                            processValuesFolder(resource.name, folder, resource.resSet, resource.resMap, cups)
                        }
                    }

                    else -> {
                        for (resource in cafeResources.filter { it.type == ResourceReadType.FILE }) {
                            if (folder.name.startsWith(resource.name)) {
                                processResourceFolder(folder, resource.resSet, resource.resMap, cups)
                            }
                        }
                    }
                }
            }
        }

        for (resource in cafeResources) {
            makeResourceCoffee(resource.name, resource.annotation, resource.resMap, coffeeList)
            makeResourceCup(
                resName = resource.name, namespace = namespace, resMap = resource.resMap, typeList = cupMap, coffee = cups
            )
        }

        val coffees = cafeResources.map { it.name }.toTypedArray()

        val coffeeFile = FileSpec.builder(coffeeClass)
        coffeeFile.addFileComment(FILE_COMMENT)

        for (cup in coffeeList) {
            coffeeFile.addType(cup.build())
        }

        coffeeFile.build().writeTo(outDir)

        val cupFile = FileSpec.builder(cupClass)
        cupFile.addFileComment(FILE_COMMENT)

        cupFile.addType(makeCupInterface(coffees))

        for (obj in cupMap.values) {
            cupFile.addType(obj.build())
        }

        cupFile.build().writeTo(outDir)


        val cafeFile = FileSpec.builder(ClassName(CAFE_PACKAGE, CAFE))
        cafeFile.addFileComment(FILE_COMMENT)

        val cafeProviderObj = TypeSpec.objectBuilder(CAFE_PROVIDER)
//            .addModifiers(KModifier.PRIVATE)

        for (type in coffees) {
            cafeProviderObj.addProperty(
                PropertySpec.builder(
                    name = type + PROVIDER, type = ClassName("androidx.compose.runtime", "ProvidableCompositionLocal").parameterizedBy(ClassName(CAFE_PACKAGE, CAFE + type.capitalized()))
                ).initializer(
                    CodeBlock.builder().addStatement("staticCompositionLocalOf<%L> { error(\"null\") }", CAFE + type.capitalized()).build()
                ).build()
            )
        }

        cafeProviderObj.addProperty(
            PropertySpec.builder(
                "cupFlow", ClassName("kotlinx.coroutines.flow", "MutableStateFlow").parameterizedBy(cupClass)
            ).initializer(
                    CodeBlock.builder().addStatement("MutableStateFlow(MAIN)").build()
                ).build()
        )


        val cafeObj = TypeSpec.objectBuilder(CAFE)

        for (type in coffees) {
            cafeObj.addProperty(
                PropertySpec.builder(type, ClassName(CAFE_PACKAGE, CAFE + type.capitalized())).getter(
                        FunSpec.getterBuilder().addAnnotation(composeAnnotation).addStatement("return $CAFE_PROVIDER.$type$PROVIDER.current").build()
                    ).build()
            )
        }


        cafeObj.addFunction(
            FunSpec.builder("set$CUP").addParameter(CUP.lowercase(), cupClass).addStatement("$CAFE_PROVIDER.${CUP.lowercase()}Flow.tryEmit(${CUP.lowercase()})").build()
        )

        cafeObj.addFunction(
            FunSpec.builder("getCup").returns(cupClass).addStatement("return $CAFE_PROVIDER.cupFlow.value").build()
        )

        val cafeFunc = FunSpec.builder(CAFE_THEME)

        cafeFunc.addAnnotation(composeAnnotation)
        cafeFunc.addParameter(
            ParameterSpec.builder(
                "content", LambdaTypeName.get(returnType = ClassName("kotlin", "Unit")).copy(
                    annotations = listOf(AnnotationSpec.builder(composeAnnotation).build())
                )
            ).build()
        )

        val compositionProvidesCode = StringBuilder()

        for (type in coffees) {
            compositionProvidesCode.append("$CAFE_PROVIDER.$type$PROVIDER provides cup.$type,\n")
        }

        cafeFunc.addCode(
            CodeBlock.builder().addStatement(
                """
                val cup by $CAFE_PROVIDER.cupFlow.collectAsState()

                CompositionLocalProvider(
                    %L
                ) {
                    content()
                }
            """.trimIndent(), compositionProvidesCode.toString()
            ).build()
        )

        cafeFile.addImport(
            "androidx.compose.runtime", *arrayOf(
                "Composable", "CompositionLocalProvider", "ProvidableCompositionLocal", "collectAsState", "getValue", "staticCompositionLocalOf"
            )
        )

        cafeFile.addType(cafeObj.build())
        cafeFile.addType(cafeProviderObj.build())
        cafeFile.addFunction(cafeFunc.build())

        cafeFile.build().writeTo(outDir)
    }

    private fun makeCupInterface(
        resNames: Array<String>
    ): TypeSpec {
        val coffeeInterface = TypeSpec.interfaceBuilder(CUP).addModifiers(KModifier.PUBLIC)
        for (res in resNames) {
            coffeeInterface.addProperty(res, ClassName(CAFE_PACKAGE, CAFE + res.capitalized()))
        }
        return coffeeInterface.build()
    }

    private fun makeResourceCoffee(
        cupName: String,
        annotation: ClassName,
        cupMap: Map<String, MutableList<String>>,
        cupList: MutableList<TypeSpec.Builder>,
    ) {
        val cupType = TypeSpec.classBuilder(CAFE + cupName.capitalized()).addModifiers(KModifier.DATA, KModifier.PUBLIC)
        val constructor = FunSpec.constructorBuilder()
        for (res in cupMap[MAIN_COFFEE].orEmpty()) {
            constructor.addParameter(res, Int::class)
            cupType.addProperty(PropertySpec.builder(res, Int::class).addAnnotation(annotation).initializer(res).build())
        }
        cupType.primaryConstructor(constructor.build())
        cupList.add(cupType)
    }

    private fun makeResourceCup(
        resName: String, namespace: String, resMap: Map<String, MutableList<String>>, typeList: MutableMap<String, TypeSpec.Builder>, coffee: Set<String>
    ) {
        //除了主资源以外，其他资源补完
        val mainSet = resMap[MAIN_COFFEE]?.map { makeResKey(it, coffee) }?.toSet().orEmpty()
        for (res in resMap) {
            if (res.key == MAIN_COFFEE) {
                continue
            }
            val coffeeSet = res.value.map { makeResKey(it, coffee) }.toSet()
            for (main in mainSet) {
                if (!coffeeSet.contains(main)) {
                    res.value.add(main)
                }
            }
        }
        for (res in resMap) {
            typeList[res.key]?.let { type ->
                val properties = mutableListOf<Pair<String, String>>()
                for (resFile in res.value) {
                    val name = makeResKey(resFile, coffee)
                    val value = "${namespace}.R.${resName}." + resFile
                    properties.add(name to value)
                }

                println("$resName has properties : $properties")

                val property = PropertySpec.builder(
                    resName, ClassName(CAFE_PACKAGE, CAFE + resName.capitalized()), KModifier.PUBLIC, KModifier.OVERRIDE
                ).initializer(
                        CodeBlock.builder().addStatement("%L(\n%L\n)", CAFE + resName.capitalized(), properties.joinToString(",\n") { "${it.first} = ${it.second}" }).build()
                    )
                type.addProperty(property.build())
            }
        }
    }

    private fun processResourceFolder(
        folder: File, resSet: MutableSet<String>, resMap: MutableMap<String, MutableList<String>>, cups: Set<String>
    ) {
        for (valueFile in folder.listFiles().orEmpty()) {
            val resFileName = valueFile.name.substring(0, valueFile.name.indexOf('.'))
            if (resSet.contains(resFileName)) {
                continue
            }
            resSet.add(resFileName)
            resMap.getOrPut(makeResCoffee(resFileName, cups)) { mutableListOf() }.add(resFileName)
        }
    }

    private fun processValuesFolder(
        resName: String, folder: File, resSet: MutableSet<String>, resMap: MutableMap<String, MutableList<String>>, cups: Set<String>
    ) {
        for (valueFile in folder.listFiles().orEmpty()) {
            val values = XmlParser().parse(valueFile)
            for (child in values.children()) {
                (child as? Node)?.let { node ->
                    val nodeName = node.name().toString()
                    if (resName == nodeName) {
                        val resValue = node.attribute("name").toString().replace('.', '_')
                        if (resSet.contains(resValue)) {
                            return@let
                        }
                        resSet.add(resValue)
                        resMap.getOrPut(makeResCoffee(resValue, cups)) { mutableListOf() }.add(resValue)
                    }
                }
            }
        }
    }
}
