package cn.loopon.cafe

import com.android.build.gradle.BaseExtension
import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.LambdaTypeName
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import groovy.util.Node
import groovy.xml.XmlParser
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.provider.SetProperty
import org.gradle.configurationcache.extensions.capitalized
import org.gradle.kotlin.dsl.create
import org.gradle.kotlin.dsl.get
import java.io.File

private const val CAFE_PACKAGE = "cn.loopon.cafe"
private const val TASK_CAFE = "cafe"
private const val EXTENSION = "cafe"
private const val MAIN_COFFEE = "main"

private const val COFFEE = "Coffee"
private const val CUP = "Cup"
private const val CAFE = "Cafe"

private const val FILE_COMMENT = "this file is auto-generated, please do not edit this file。\n该文件是自动生成的文件，请不要编辑。\n"

interface CafePluginExtension {
    val cup: SetProperty<String>
}

enum class ResourceReadType {
    FILE,XML
}

data class CafeResource(
    val name: String,
    val type:ResourceReadType,
    val annotation:ClassName,
    val resMap: MutableMap<String, MutableList<String>> = mutableMapOf(),
    val resSet: MutableSet<String> = mutableSetOf<String>()
)

private val cafeResources = listOf<CafeResource>(
    CafeResource("color", ResourceReadType.XML, ClassName("androidx.annotation", "ColorRes")),
    CafeResource("mipmap",ResourceReadType.FILE, ClassName("androidx.annotation", "DrawableRes")),
    CafeResource("drawable",ResourceReadType.FILE, ClassName("androidx.annotation", "DrawableRes")),
)

private val composeAnnotation = ClassName("androidx.compose.runtime","Composable")
private val cupClass = ClassName(CAFE_PACKAGE, CUP)
private val coffeeClass = ClassName(CAFE_PACKAGE, COFFEE)

class CafePlugin : Plugin<Project> {

    override fun apply(target: Project) {

        println("Cafe")

        val cafeExtension = target.extensions.create<CafePluginExtension>(EXTENSION)
        cafeExtension.cup.convention(emptySet())

        target.tasks.register(TASK_CAFE) task@{

            target.androidProject()?.let { android ->
                println("make coffee for ${android.namespace}")
                val cafeDir = android.sourceSets["main"].java.srcDirs.first()
                generateCafeFile(namespace = android.namespace.orEmpty(), variant = "", target = android, buildDir = target.buildDir, cups = cafeExtension.cup.get(), outDir = cafeDir)
                return@task
            }

            target.libraryProject()?.let { android ->
                println("make coffee for ${android.namespace}")
                val cafeDir = android.sourceSets["main"].java.srcDirs.first()
                generateCafeFile(namespace = android.namespace.orEmpty(), variant = "", target = android, buildDir = target.buildDir, cups = cafeExtension.cup.get(), outDir = cafeDir)
                return@task
            }
        }
        target.tasks["preBuild"].finalizedBy(TASK_CAFE)
    }

    private fun makeResCoffee(res: String, cups: Set<String>): String {
        if (cups.isEmpty()) {
            return MAIN_COFFEE
        }
        for (coffee in cups) {
            if (res.lastIndexOf("_$coffee") > -1) {
                return coffee
            }
        }
        return MAIN_COFFEE
    }

    private fun makeResKey(res: String, cups: Set<String>): String {
        if (cups.isEmpty()) {
            return res
        }
        for (coffee in cups) {
            val suffixCoffee = res.lastIndexOf("_$coffee")
            if (suffixCoffee > -1) {
                return res.substring(0, suffixCoffee)
            }
        }
        return res
    }

    private fun generateCafeFile(namespace: String, variant: String, target: BaseExtension, buildDir: File, cups: Set<String>, outDir: File) {

        println("make $cups coffee")

        val mainSet = target.sourceSets["main"]

        val coffeeList = mutableListOf<TypeSpec.Builder>()

        val cupMap = mutableMapOf<String, TypeSpec.Builder>()
        cupMap[MAIN_COFFEE] = TypeSpec.objectBuilder(MAIN_COFFEE.uppercase()).addSuperinterface(cupClass)

//        val colorMap = mutableMapOf<String, MutableList<String>>()
//        val colorSet = mutableSetOf<String>()
//
//        val mipmapMap = mutableMapOf<String, MutableList<String>>()
//        val mipmapSet = mutableSetOf<String>()
//
//        val drawableMap = mutableMapOf<String, MutableList<String>>()
//        val drawableSet = mutableSetOf<String>()

        for (obj in cups) {
            cupMap[obj] = TypeSpec.objectBuilder(obj.uppercase()).addSuperinterface(cupClass)
            for (resource in cafeResources) {
                resource.resMap[obj] = mutableListOf()
            }
        }

        for (resFile in mainSet.res.srcDirs) {
            val files = resFile.listFiles().orEmpty()
            for (folder in files) {
                when {
                    folder.name.startsWith("values") -> {
                        for (resource in cafeResources.filter { it.type == ResourceReadType.XML }) {
                            processValuesFolder(resource.name, folder, resource.resSet, resource.resMap, cups)
                        }
                    }

                    else -> {
                        for (resource in cafeResources.filter { it.type == ResourceReadType.FILE }) {
                            if (folder.name.startsWith(resource.name)) {
                                processResourceFolder(folder, resource.resSet, resource.resMap, cups)
                            }
                        }
                    }
                }
            }
        }

        for (resource in cafeResources) {
            makeResourceCoffee(resource.name, resource.annotation, resource.resMap, coffeeList)
            makeResourceCup(
                resName = resource.name,
                namespace = namespace,
                resMap = resource.resMap,
                typeList = cupMap,
                coffee = cups
            )
        }

        val coffees = cafeResources.map { it.name }.toTypedArray()

        val coffeeFile = FileSpec.builder(coffeeClass)
        coffeeFile.addFileComment(FILE_COMMENT)

        for (cup in coffeeList) {
            coffeeFile.addType(cup.build())
        }

        coffeeFile.build().writeTo(outDir)

        val cupFile = FileSpec.builder(cupClass)
        cupFile.addFileComment(FILE_COMMENT)

        cupFile.addType(makeCupInterface(coffees))

        for (obj in cupMap.values) {
            cupFile.addType(obj.build())
        }

        cupFile.build().writeTo(outDir)


        val cafeFile = FileSpec.builder(ClassName(CAFE_PACKAGE, CAFE))
        cafeFile.addFileComment(FILE_COMMENT)

        val cafeObj = TypeSpec.objectBuilder(CAFE)

        for (type in coffees) {
            cafeObj.addProperty(
                PropertySpec.builder(
                    name = type,
                    type = ClassName("androidx.compose.runtime", "ProvidableCompositionLocal").parameterizedBy(ClassName(CAFE_PACKAGE, CAFE + type.capitalized()))
                ).initializer(
                        CodeBlock
                            .builder()
                            .addStatement("staticCompositionLocalOf<%L> { error(\"null\") }", CAFE + type.capitalized()).build()
                    ).build()
            )
        }

        cafeObj.addProperty(
            PropertySpec.builder("_themeFlow", ClassName("kotlinx.coroutines.flow","MutableStateFlow").parameterizedBy(cupClass))
                .initializer(
                    CodeBlock
                        .builder()
                        .addStatement("MutableStateFlow<Cup>(MAIN)")
                        .build()
                )
                .build()
        )

        cafeObj.addFunction(FunSpec.builder("setTheme")
            .addParameter("theme", cupClass)
            .addStatement("_themeFlow.tryEmit(theme)")
            .build())

        cafeObj.addFunction(FunSpec.builder("getTheme")
            .returns(ClassName("kotlinx.coroutines.flow","StateFlow").parameterizedBy(cupClass))
            .addStatement("return _themeFlow")
            .build())



        val cafeFunc = FunSpec.builder("CafeTheme")


        cafeFunc.addAnnotation(composeAnnotation)
        cafeFunc.addParameter(
            ParameterSpec.builder("content",
                LambdaTypeName.get(returnType = ClassName("kotlin","Unit")).copy(
                    annotations = listOf(AnnotationSpec.builder(composeAnnotation).build())
                )
            )
                .build()
        )

        val compositionProvidesCode = StringBuilder()

        for (type in coffees) {
            compositionProvidesCode.append("$CAFE.$type provides theme.$type,\n")
        }



        cafeFunc.addCode(
            CodeBlock.builder().addStatement(
                """
                val theme by Cafe.getTheme().collectAsState()

                CompositionLocalProvider(
                    %L
                ) {
                    content()
                }
            """.trimIndent(), compositionProvidesCode.toString()
            ).build()
        )

        cafeFile.addImport(
            "androidx.compose.runtime",
            *arrayOf("Composable",
                    "CompositionLocalProvider",
                    "ProvidableCompositionLocal",
                    "collectAsState",
                    "getValue",
                    "staticCompositionLocalOf")
        )
        cafeFile.addType(cafeObj.build())
        cafeFile.addFunction(cafeFunc.build())

        cafeFile.build().writeTo(outDir)
    }

    private fun makeCupInterface(
        resNames: Array<String>
    ): TypeSpec {
        val coffeeInterface = TypeSpec.interfaceBuilder(CUP).addModifiers(KModifier.PUBLIC)
        for (res in resNames) {
            coffeeInterface.addProperty(res, ClassName(CAFE_PACKAGE, CAFE + res.capitalized()))
        }
        return coffeeInterface.build()
    }

    private fun makeResourceCoffee(
        cupName: String,
        annotation: ClassName,
        cupMap: Map<String, MutableList<String>>,
        cupList: MutableList<TypeSpec.Builder>,
    ) {
        val cupType = TypeSpec.classBuilder(CAFE + cupName.capitalized()).addModifiers(KModifier.DATA, KModifier.PUBLIC)
        val constructor = FunSpec.constructorBuilder()
        for (res in cupMap[MAIN_COFFEE].orEmpty()) {
            constructor.addParameter(res, Int::class)
            cupType.addProperty(PropertySpec.builder(res, Int::class).addAnnotation(annotation).initializer(res).build())
        }
        cupType.primaryConstructor(constructor.build())
        cupList.add(cupType)
    }

    private fun makeResourceCup(
        resName: String,
        namespace: String,
        resMap: Map<String, MutableList<String>>,
        typeList: MutableMap<String, TypeSpec.Builder>,
        coffee: Set<String>
    ) {
        //除了主资源以外，其他资源补完
        val mainSet = resMap[MAIN_COFFEE]?.map { makeResKey(it, coffee) }?.toSet().orEmpty()
        for (res in resMap) {
            if (res.key == MAIN_COFFEE) {
                continue
            }
            val coffeeSet = res.value.map { makeResKey(it, coffee) }.toSet()
            for (main in mainSet) {
                if (!coffeeSet.contains(main)) {
                    res.value.add(main)
                }
            }
        }
        for (res in resMap) {
            typeList[res.key]?.let { type ->
                val properties = mutableListOf<Pair<String, String>>()
                for (resFile in res.value) {
                    val name = makeResKey(resFile, coffee)
                    val value = "${namespace}.R.${resName}." + resFile
                    properties.add(name to value)
                }

                val property = PropertySpec.builder(resName,
                    ClassName(CAFE_PACKAGE, CAFE + resName.capitalized()), KModifier.PUBLIC, KModifier.OVERRIDE)
                    .initializer(
                        CodeBlock.builder().addStatement("%L(\n%L\n)", CAFE + resName.capitalized(), properties.joinToString(",\n") { "${it.first} = ${it.second}" }).build()
                    )
                type.addProperty(property.build())
            }
        }
    }

    private fun processResourceFolder(
        folder: File, resSet: MutableSet<String>, resMap: MutableMap<String, MutableList<String>>, cups: Set<String>
    ) {
        for (valueFile in folder.listFiles().orEmpty()) {
            val resFileName = valueFile.name.substring(0, valueFile.name.indexOf('.'))
            if (resSet.contains(resFileName)) {
                continue
            }
            resSet.add(resFileName)
            resMap.getOrPut(makeResCoffee(resFileName, cups)) { mutableListOf() }.add(resFileName)
        }
    }

    private fun processValuesFolder(
        resName: String, folder: File, resSet: MutableSet<String>, resMap: MutableMap<String, MutableList<String>>, coffee: Set<String>
    ) {
        for (valueFile in folder.listFiles().orEmpty()) {
            val values = XmlParser().parse(valueFile)
            for (child in values.children()) {
                (child as Node).let { node ->
                    val nodeName = node.name().toString()
                    if (resName == nodeName) {
                        val resValue = node.attribute("name").toString().replace('.', '_')
                        if (resSet.contains(resValue)) {
                            return@let
                        }
                        resSet.add(resValue)
                        resMap.getOrPut(makeResCoffee(resValue, coffee)) { mutableListOf() }.add(resValue)
                    }
                }
            }
        }
    }
}
